// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.




#include "Drive.h"
#include "../Robotmap.h"
#include "../Commands/DriveTog.h"

Drive::Drive() : Subsystem("Drive") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	speedController1 = RobotMap::driveSpeedController1;
	speedController2 = RobotMap::driveSpeedController2;
	speedController3 = RobotMap::driveSpeedController3;
	speedController4 = RobotMap::driveSpeedController4;
	quadEncoder1 = RobotMap::encoderQuadEncoder1;
	quadEncoder2 = RobotMap::encoderQuadEncoder2;
	sucker = RobotMap::pickupWheelsTopWheels;
	Arm1 = RobotMap::pickupWheelsSpike1;
	Arm2 = RobotMap::pickupWheelsSpike2;
	armLimit1 = RobotMap::pickupWheelsLimitSwitch1;
	armLimit2 = RobotMap::pickupWheelsLimitSwitch2;
	ballistMotor1 = RobotMap::ballistSpeedController1;
	ballistMotor2 = RobotMap::ballistSpeedController2;
	ballistMotor3 = RobotMap::ballistSpeedController3;
	ballistMotor4 = RobotMap::ballistSpeedController4;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drive::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveTog());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

	//quadEncoder1->Reset();//
	//quadEncoder2->Reset();//

	quadEncoder1->Start();//
	quadEncoder2->Start();//

	dThrot=0;
	count=0;
	count1=0;
	time1=0;
	count2=0;
	time2=0;

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drive::SetSpeed1(Joystick* stick)
{
//	printf("Setting SPEED!!!!!!!!!!!!!!");
	if(stick->GetRawButton(1))
	{
		speedController1 -> Set(stick -> GetY()*.5);
		speedController2 -> Set(stick -> GetY()*.5);
	}

	else
	{
		speedController1 -> Set(stick -> GetY()*-1);
		speedController2 -> Set(stick -> GetY()*-1);
	}
}

void Drive::SetSpeed2(Joystick* stick)
{
	if(stick->GetRawButton(1))
	{
		speedController3 -> Set(stick -> GetY()*.5);
		speedController4 -> Set(stick -> GetY()*.5);
	}

	else 
	{
		speedController3 -> Set(stick -> GetY()*1);
		speedController4 -> Set(stick -> GetY()*1);
	}
}

void Drive::Stop()
{
	speedController1 -> Set(0);
	speedController2 -> Set(0);
	speedController3 -> Set(0);
	speedController4 -> Set(0);
}

void Drive::autoForward()
{
	long quad1=quadEncoder1->Get();
	long quad2=quadEncoder2->Get();

	double enc1Rate=quadEncoder1->GetRate();
	double enc2Rate=quadEncoder2->GetRate();

	printf("enc1 %ld \n",quad1);//
	printf(" enc2 %ld \n",quad2);//
	printf("enc1rate: %f \n",enc1Rate);
	printf(" enc2rate: %f \n",enc2Rate);

	float error = enc1Rate-enc2Rate;
	dThrot+= .0001*error;

	printf("%f \n",dThrot);
	if(abs(quad1) < (2310) && abs(quad2)<(2310))//.0785
	{
		printf("quad1 %ld \n",quad1);//
		printf(" quad2 %ld \n",quad2);//
		speedController1 -> Set(.3-dThrot);
		speedController2 -> Set(.3-dThrot);
		speedController3 -> Set(-.3-dThrot);//-.47
		speedController4 -> Set(-.3-dThrot);//-.47

	}
	else
	{
		printf("quads off\n");
		speedController1 -> Set(0);
		speedController2 -> Set(0);
		speedController3 -> Set(0);
		speedController4 -> Set(0);
		sucker->Set(1);
	}
}


/* Test a ramp input to get up to speed. Should incorporate into the above method.
void Drive::autoForward()
{
	printf("%0.4f/n", count);


	if(count<.5)
	{
		speedController1 -> Set(count);
		speedController2 -> Set(count);
		speedController3 -> Set(count);
		speedController4 -> Set(count);
		count=count+.005;
	}	

	else 
	{
		speedController1 -> Set(0);
		speedController2 -> Set(0);
		speedController3 -> Set(0);
		speedController4 -> Set(0);
	}

}
 */

void Drive::autoBackward()
{
	long quad1=quadEncoder1->Get();
	long quad2=quadEncoder2->Get();

	double enc1Rate=quadEncoder1->GetRate();
	double enc2Rate=quadEncoder2->GetRate();

	printf("enc1 %ld \n",quad1);//
	printf(" enc2 %ld \n",quad2);//
	printf("enc1rate: %f \n",enc1Rate);
	printf(" enc2rate: %f \n",enc2Rate);

	float error = enc1Rate-enc2Rate;
	dThrot+= .0001*error;

	printf("%f \n",dThrot);
	if(abs(quad1) < (2310) && abs(quad2)<(2310))//.0785
	{
		printf("quad1 %ld \n",quad1);//
		printf(" quad2 %ld \n",quad2);//
		speedController1 -> Set(-.3-dThrot);
		speedController2 -> Set(-.3-dThrot);
		speedController3 -> Set(.3-dThrot);//-.47
		speedController4 -> Set(.3-dThrot);//-.47
	}
	else
	{
		printf("quads off\n");
		speedController1 -> Set(0);
		speedController2 -> Set(0);
		speedController3 -> Set(0);
		speedController4 -> Set(0);

		// wait 1 second for robot to stop rolling
		if (time1 > 1){
			// move the arms forward till both limit switches hit
			if (armLimit1 -> Get() != 0 && armLimit2 -> Get() != 0) {
				if (armLimit1 -> Get() == 0)
					Arm1 -> Set(Relay::kOff);
				else
					Arm1 ->Set(Relay::kForward);
				
				if (armLimit2 -> Get() == 0)
					Arm2 -> Set(Relay::kOff);
				else
					Arm2 -> Set(Relay::kForward);
			}
			// both limit switches have hit, so we can shoot (need another counter here and stop/retract after shot
			else {
				if (time2<0.3) {
					ballistMotor1 -> Set(.5);				
					ballistMotor2 -> Set(.5);				
					ballistMotor3 -> Set(.5);				
					ballistMotor4 -> Set(.5);				
				}
				else if (time2<1) {
					ballistMotor1 -> Set(0);				
					ballistMotor2 -> Set(0);				
					ballistMotor3 -> Set(0);				
					ballistMotor4 -> Set(0);
				}
				else { // can retract here if we want
					ballistMotor1 -> Set(0);				
					ballistMotor2 -> Set(0);				
					ballistMotor3 -> Set(0);				
					ballistMotor4 -> Set(0);
				}
				count2++;
				time2=0.2*count2;
			}
		}

		count1++;
		time1=count1*0.02;
	}
}
